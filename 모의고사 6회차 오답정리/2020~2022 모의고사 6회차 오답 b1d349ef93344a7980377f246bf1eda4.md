# 2020~2022 모의고사 6회차 오답

<aside>
❓ **시스템의 구성요소로 볼 수 없는 것은?**

</aside>

1. Process
2. Feedback
3. Maintenance
4. Control

- **Answer**
    1. Maintenance
    
    시스템 구성요소
    
    입력 (Input) : 처리 방법, 처리할 데이터, 조건을 시스템에 투입하는 것
    
    처리 (Process) : 입력된 데이터를 처리 방법과 조건에 따라 처리하는 것
    
    출력 (Output) : 처리된 결과를 시스템에서 산출하는 것
    
    제어 (Control) : 자료를 입력하여 출력될 때까지의 처리 과정이 올바르게 진행되는지 감독하는 것
    
    피드백 (Feedback) : 출력된 결과가 예정된 목표를 만족시키지 못할 경우 목표 달성을 위해 반복 처리하는 것
    
    Maintenance는 유지보수로서, 시스템 구성요소에는 포함되지 않음.
    

<aside>
❓ **럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용되는 다이어그램은?**

</aside>

1. 객체 다이어그램(Object Diagram)
2. 패키지 다이어그램(Package Diagram)
3. 상태 다이어그램(State Diagram)
4. 자료 흐름도(Data Flow Diagram)

- **Answer**
    1. 상태 다이어그램(State Diagram)
    
    동적 모델링(Dynamic Modeling)은 상태 다이어그램(상태도)를 이용해 시간 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링을 말한다.
    
    [해설작성자 : 정보처리지기]
    
    - 럼바우(Rumbaugh) : 소프트웨어 구성요소를 그래픽 표기법으로 이용한 모델링
    - " 분석: 객체 모델링, 동적 모델링, 기능 모델링
    
    객체모델링:객체 다이어그램으로 표시, 가장 중요시 선행
    
    동적모델링:상태 다이어그램(상태도), 동적인 흐름 행위
    
    기능모델링:자료의 흐름을 이용하여 프로세스간의 자료 흐름을 처리
    

<aside>
❓ **UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?**

</aside>

1. 《 》
2. (( ))
3. {{ }}
4. [[ ]]

- **Answer**
    1. 《 》
    

<aside>
❓ **객체지향 기법에서 클래스들 사이의 ‘부분-전체(part-whole)' 관계 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타내는 용어는?**

</aside>

1. 일반화
2. 추상화
3. 캡슐화
4. 집단화

- **Answer**
    1. 집단화
    
    집단화 is part of(part가 들어가면 집단화 생각) : 클래스 간의 구조적인 집약 관계 "클래스 A는 클래스 B와 클래스 C로 구성된다"
    
    일반화 is a :클래스들 간의 개념적인 포함 관계  "자식 클래스 A는 부모 클래스 B의 일종이다."
    
    캡슐화 : 속성 (데이터)과 메소드(연산) 을 하나로 묶어서 객체로 구성된다.
    
    추상화 : 공통 성질을 추출하여 수퍼클래스로 구성한다. 또한 객체 중심의 안정된 모델을 구축 가능 하며 현실 세계를 자연스럽게 표현한다. 장점으로 분석의 초점이 명확해진다.
    

<aside>
❓ **유스케이스 다이어그램(Use Case Diagram)에 관련된 내용으로 틀린 것은?**

</aside>

1. 시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다.
2. 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.
3. 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.
4. 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.

- **Answer**
    1. 시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다.
    
    액터: 시스템과 상호작용하는 모든 것(사람, 기계, 시스템 등)
    

<aside>
❓ **소프트웨어를 재사용함으로써 얻을 수 있는 이점으로 가장 거리가 먼 것은?**

</aside>

1. 생산성 증가
2. 프로젝트 문서 공유
3. 소프트웨어 품질 향상
4. 새로운 개발 방법론 도입 용이

- **Answer**
    
    4. 새로운 개발 방법론 도입 용이
    
    - *소프트웨어 재사용함으로써 얻을 수 있는 이점들**
    
    1. 개발 시간과 비용 단축
    
    2. 소프트웨어 품질 및 생산성 향상
    
    3. 프로젝트 실패 위험 감소
    
    4. 시스템 구축 방법에 대한 지식 공유
    
    - *소프트웨어 재사용함으로써 얻을 수 있는 문제점들**
    
    1. 재사용할 소프트 웨어 선정 필요
    
    2. 시스템에 공통적으로 사용되는 요소 발견 필요
    
    3. 프로그램의 표준화 부족
    
    4. 새로운 개발 방법론 도입이 어려움
    
    5. 재사용을 위한 관리 및 지원 부족
    
    6. 기존 소프트웨어에 재사용 소프트웨어를 추가하기 어려움
    

<aside>
❓ **인터페이스 간의 통신을 위해 이용되는 데이터 포맷이 아닌 것은?**

</aside>

1. AJTML
2. JSON
3. XML
4. YAML

- **Answer**
    1. AJTML
    
    ▶JSON(Javascript Object Notation)
    
    속성-값 쌍 또는 “키-값 쌍”으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷, AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷
    
    ▶ XML(Extensible Markup Language)
    
    HTML의 단점을 보완한 인터넷 언어, SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어
    
    ▶ AJAX(Asynchronous Javascript And XML)
    
    자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술, XMLHttpRequest 객체를 이용해 전체 페이지를 새로 로드하지 않고 필요한 부분만 로드한다.
    
    ▶ REST(Representational State Transfer)
    
    ⦁  웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍처 (리소스, 메서드, 메시지)
    
    ⦁  HTTP URI를 통해 자원을 명시하고, HTTP 메서드(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 생성, 조회, 갱신, 삭제 등의 명령을 적용할 수 있는 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처이다.
    
    [해설작성자 : 강썬]
    
    YAML: JSON과 비슷하게 사람이 읽기 쉬운 형태의 데이터 표현 형식.
    
    - YAML은 XML과 문법적으로 유사한 점이 많음.
    - YAML에서도 주석을 사용 가능하며 개행, 공백으로 블록을 인식.
    - 태그를 사용하지 않고 공백 위주로 데이터를 구분하므로 한 줄로 작성할 수 없다는 특징.

<aside>
❓ **다음이 설명하는 테스트 용어는?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%206%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20b1d349ef93344a7980377f246bf1eda4/Untitled.png)

1. 테스트 케이스
2. 테스트 시나리오
3. 테스트 오라클
4. 테스트 데이터

- **Answer**
    1. 테스트 오라클
    
    테스트 케이스 : 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
    
    테스트 시나리오 : 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합
    
    테스트 오라클 : 문제 참조
    

<aside>
❓ **단위 테스트(Unit Test)와 관련한 설명으로 틀린 것은?**

</aside>

1. 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
2. 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
3. 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.
4. 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.

- **Answer**
    1. 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.
    
    필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(test driver)라고 한다. 반대로 테스트 스텁(test stub)은 인자를 통해 받은 값을 가지고 수행한 후 그 결과를 테스트할 모듈에 넘겨주는 역할을 한다.
    

<aside>
❓ **릴레이션 R의 모든 결정자(determinant)가 후보키이면 그 릴레이션 R은 어떤 정규형에 속하는가?**

</aside>

1. 제 1정규형
2. 제 2정규형
3. 보이스/코드 정규형
4. 제 4정규형

- **Answer**
    1. 보이스/코드 정규형
    
    1NF : 도메인이 원자값만으로 구성된 정규형
    
    2NF : 기본 키가 아닌 모든 속성이 기본 키에 대해 완전 함수적 종속을 만족하는 정규형
    
    3NF : 기본 키가 아닌 모든 속성이 기본 키에 대해 이행적 종속을 만족 안하는 정규형
    
    BCNF : 모든 결정자가 후보 키인 정규형 *
    
    4NF : 다치 종속 A->B가 성립하는 경우 A에 함수적 종속 관계를 만족하는 정규형
    
    5NF : 모든 조인 종속이 후보 키를 통해서만 성립되는 정규형
    

<aside>
❓ **분산 데이터베이스의 투명성(Transparency)에 해당 하지 않는 것은?**

</aside>

1. Location Transparency
2. Replication Transparency
3. Failure Transparency
4. Media Access Transparency

- **Answer**
    1. Media Access Transparency
    
    분산데이터베이스 투명성 조건
    
    분산데이터베이스는 6가지 투명성(Transparency)을 만족해야 한다.
    
    1. 분할 투명성 : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
    
    2. 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요. 위치정보가 시스템 카탈로그에 유지되어야 함
    
    3. 지역사상 투명성 : 지역DBMS와 물리적 DB사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용 가능
    
    4. 중복 투명성 : DB 객체가 여러 site에 중복 되어 있는지 알 필요가 없는 성질
    
    5. 장애 투명성 : 구성요소(DBMS 등)의 장애에 무관한 트랜잭션의 원자성 유지
    
    6. 병행 투명성 : 다수 트랜잭션 동시 수행시 결과의 일관성 유지, Time Stamp, 2PL 구현
    

<aside>
❓ **데이터베이스에서 개념적 설계 단계에 대한 설명으로 틀린 것은?**

</aside>

1. 산출물로 E-R Diagram을 만들 수 있다.
2. DBMS에 독립적인 개념 스키마를 설계한다.
3. 트랜잭션 인터페이스를 설계 및 작성한다.
4. 논리적 설계 단계의 앞 단계에서 수행된다.

- **Answer**
    1. 트랜잭션 인터페이스를 설계 및 작성한다.
    
    데이터베이스 설계단계에서의 트랜잭션 설계단계
    
    - 개념설계 : 트랜잭션 모델링
    - 논리설계 : 트랜잭션 인터페이스 설계
    - 물리설계 : 트랜잭션 세부설계

<aside>
❓ 모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도(Cohesion)는?

</aside>

1. Temporal Cohesion
2. Logical Cohesion
3. Coincidental Cohesion
4. Sequential Cohesion

- **Answer**
    1. Temporal Cohesion
    
    Temporal Cohension(시간적 응집도)를 설명하는 문제이다.
    
    - Logical Cohension(논리적 응집도): 모듈 내 구성 요소들이 같은 범주에 속하는 기능끼리 묶인 경우(ex. 새글, 불러오기, 저장하기, 다른이름으로 저장하기)
    - Coincidental Cohension(우연적 응집도): 모듈 내 구성 요소들이 뚜렷한 관계없이 묶인 경우
    - Sequential Cohension(순차적 응집도): 모듈 내 구성 요소들이 이전의 명령어로부터 나온 출력결과를 그 다음 명령어의 입력자료로 사용하는 경우(ex. 총점과 평균의 관계)

<aside>
❓ **IP 프로토콜에서 사용하는 필드와 해당 필드에 대한 설명으로 틀린 것은?**

</aside>

1. Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
2. Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다.
3. Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
4. Version Number는 IP 프로토콜의 버전번호를 나타낸다.

- **Answer**
    1. Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다.
    
    Total Packet Length (16 bits): IP 헤더 및 데이터를 포함한 IP 패킷 전체 길이를 바이트 단위로 길이를 표시. (최대값은 65,535 = 2^16 - 1)
    

<aside>
❓ **IPv6의 주소체계로 거리가 먼 것은?**

</aside>

1. Unicast
2. Anycast
3. Broadcast
4. Multicast

- **Answer**
    1. Broadcast
    
    IPv6 : 유니캐스트(unicast) 멀티캐스트(multicast) 애니캐스트(anycast)
    
    IPv4 : 유니캐스트(unicast) 멀티캐스트(multicast) 브로드캐스트(Broadcast)
    

<aside>
❓ **페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은?**

</aside>

1. 기억장소 이용 효율이 증가한다.
2. 입·출력 시간이 늘어난다.
3. 내부 단편화가 감소한다.
4. 페이지 맵 테이블의 크기가 감소한다.

- **Answer**
    1. 페이지 맵 테이블의 크기가 감소한다.
    
    페이징 기법 : 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법
    
    페이징기법을 통해 물리적 메모리는 연속적으로 할당되어 존재할 필요가 없음
    
    페이징기법을 통해 비연속적 메모리를 연속적메모리처럼 만들 수 있음
    
    - 페이지 크기가 작은경우
    
    더 많은 페이징 사상테이블 필요
    
    내부 단편화 감소
    
    페이지의 집합을 효율적으로 운영가능
    
    기억장치의 효율이 좋음
    
    총 입출력 시간 증가
    
    - 페이지크기가 큼
    
    주기억 장치 공간 절약
    
    참조되는 정보와 무관한 양의 정보가 주기억 장치에 남게 됨
    
    테이블이 복잡하지 않아 관리 용이
    

<aside>
❓ **다음 중 페이지 교체(Page Replacement)알고리즘이 아닌 것은?**

</aside>

1. FIFO(First-In-First-Out)
2. LUF(Least Used First)
3. Optimal
4. LRU(Least Recently Used)

- **Answer**
    1. LUF(Least Used First)
    
    페이지 교체 알고리즘의 종류
    
    OPT - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
    
    FIFO - First In First Out
    
    LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
    
    LFU - Least Frequently Used : 참조 횟수가 가장 적은 페이지 교체
    
    MFU - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
    
    NUR - Not Used Recently : 최근에 사용하지 않은 페이지 교체
    

<aside>
❓ **어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티는?**

</aside>

1. tcp wrapper
2. trace checker
3. token finder
4. change detector

- **Answer**
    1. tcp wrapper
    
    tcp/ip 통신에서, tcp는 3-way handshake 를 통해 통신이 원활히 이뤄질 수 있는지를 확인합니다.
    

<aside>
❓ **라우팅 프로토콜인 OSPF(Open Shortest Path First)에 대한 설명으로 옳지 않은 것은?**

</aside>

1. 네트워크 변화에 신속하게 대처할 수 있다.
2. 거리 벡터 라우팅 프로토콜이라고 한다.
3. 멀티캐스팅을 지원한다.
4. 최단 경로 탐색에 Dijkstra 알고리즘을 사용한다.

- **Answer**
    1. 거리 벡터 라우팅 프로토콜이라고 한다.
    
    거리 벡터 라우팅 프로토콜
    
    - Bellman-Ford 알고리즘 사용
    - RIP 프로토콜(최대 홉 수 15)
    - 인접 라우터와 주기적으로 정보 교환
    
    링크 상태 라우팅 프로토콜
    
    - Dijkstra 알고리즘 사용
    - OSPF 프로토콜(홉 수 제한 없음)
    - 최단 경로, 최소 지연, 최대 처리량