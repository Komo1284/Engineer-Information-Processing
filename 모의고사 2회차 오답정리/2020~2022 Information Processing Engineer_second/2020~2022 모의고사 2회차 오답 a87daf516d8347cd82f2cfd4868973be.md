# 2020~2022 모의고사 2회차 오답

<aside>
❓ **럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용되는 다이어그램은?**

</aside>

1. 객체 다이어그램(Object Diagram)
2. 패키지 다이어그램(Package Diagram)
3. 상태 다이어그램(State Diagram)
4. 자료 흐름도(Data Flow Diagram)

- **Answer**
    1. 상태 다이어그램(State Diagram)
    
    - 럼바우(Rumbaugh) : 소프트웨어 구성요소를 그래픽 표기법으로 이용한 모델링
    - " 분석: 객체 모델링, 동적 모델링, 기능 모델링
    
    객체모델링:객체 다이어그램으로 표시, 가장 중요시 선행
    
    동적모델링:상태 다이어그램(상태도), 동적인 흐름 행위
    
    기능모델링:자료의 흐름을 이용하여 프로세스간의 자료 흐름을 처리
    

<aside>
❓ **GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?**

</aside>

1. factory method pattern은 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성하도록 하는 방식이다.
2. prototype pattern은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.
3. bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.
4. mediator pattern은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.

- **Answer**
    1. bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.
    
    bridge pattern은 구현부에서 추상층을 분리하여 각자 독립적으로 확장이 가능하게 하는 패턴이다
    

<aside>
❓ **객체지향 분석 방법론 중 Coad-Yourdon 방법에 해당하는 것은?**

</aside>

1. E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.
2. 객체, 동적, 기능 모델로 나누어 수행하는 방법이다.
3. 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 방법이다.
4. Use-Case를 강조하여 사용하는 방법이다.

- **Answer**
    1. E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.
    
    객체지향 분석 방법론
    
    1.Booch(부치)
    
    - 미시적, 거시적 개발 프로세스를 모두 사용하는 분석방법.
    - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
    
    2. Jacobson(제이콥슨)
    
    - Use Case를 사용하여 분석(사용자, 외부 시스템, 다른 요소들이 시스템과 상호 작용 하는 방법을 기술)
    
    3. Coad-Yourdon
    
    - E-R 다이어그램을 사용하여 객체의 행위를 모델링
    - 객체 식별, 구조 식별
    
    4. Wirfs-Brock
    
    - 분석과 설계간 구분이 없으며, 고객 명세서를 평가하여 설계 작업까지 연속적으로 수행

<aside>
❓ **다음 중 자료사전(Data Dictionary)에서 선택의 의미를 나타내는 것은?**

</aside>

1. [ ]
2. { }
3. +
4. =

- **Answer**
    1. [ ]
    
    = : 자료의 정의(~로 구성되어 있다)
    
    + : 자료의 연결(그리고)
    
    () : 자료의 생략(생략 가능한 자료)
    
    [] : 자료의 선택(또는) ex) [ A | B | C ]
    
    {} : 자료의 반복
    
    - * : 자료의 설명(주석)

<aside>
❓ **UML 다이어그램이 아닌 것은?**

</aside>

1. 액티비티 다이어그램(Activity diagram)
2. 절차 다이어그램(Procedural diagram)
3. 클래스 다이어그램(Class diagram)
4. 시퀀스 다이어그램(Sequence diagram)

- **Answer**
    1. 절차 다이어그램(Procedural diagram)
    
    업무의 흐름을 모델링하거나 객체의 생명 주기를 표현하는 Activity 다이어그램
    
    객체 간의 메시지 전달을 시간적 흐름에서 분석하는 Sequence 다이어그램
    
    기업 환경의 구성과 컴포넌트들 간의 관계를 그린 Deployment 다이어그램
    
    객체와 객체가 주고받는 메시지 중심의 작성 동적 다이어그램인 Collaboration 다이어그램
    
    소프트웨어 구조가 그리는 Component 다이어그램
    
    시스템의 구조적인 모습을 그리는 Class 다이어그램
    

<aside>
❓ **객체지향 분석 기법과 관련한 설명으로 틀린것은?**

</aside>

1. 동적 모델링 기법이 사용될 수 있다.
2. 기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.
3. 데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다.
4. 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.

- **Answer**
    1. 기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.
    
    객체지향 분석 기법
    
    1. 동적 모델링
    
    2. 상향식
    

<aside>
❓ **다음 설명의 소프트웨어 테스트의 기본원칙은?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled.png)

1. 살충제 패러독스
2. 결함 집중
3. 오류 부재의 궤변
4. 완벽한 테스팅은 불가능

- **Answer**
    1. 결함 집중
    
    살충제 패러독스: 동일한 테스트 케이스로 반복 실행하면 더이상 새로운 결함을 발견할 수 없으므로 주기적으로 테스트 케이스를 점검하고 개선해야 한다.
    
    오류 부재의 궤변: 사용자의 요구사항을 만족하지 못한다면 오류를 발견하고 제거해도 품질이 높다고 말할 수 없다.
    

<aside>
❓ **인터페이스 구현 검증도구 중 아래에서 설명하는 것은?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled%201.png)

1. xUnit
2. STAF
3. FitNesse
4. RubyNode

- **Answer**
    1. STAF
    
    인터페이스 구현 검증 도구
    
    xUnit : Java, C++ 등 다양한 언어 지원하는 단위 테스트 프레임워크
    
    STAF : 서비스 호출 및 컴포넌트 재사용 등 환경 지원하는 테스트 프레임워크
    
    FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
    
    NTAF : FitNesse의 장점인 협업 기능과  STAF의 장점인 재사용 및 확장성을 통합한 네이버의 테스트 자동화 프레임워크이다.
    
    Selenium : 다양한 브라우저 및 개발 언어 지원하는 웹 애플리케이션 테스트 프레임워크
    
    Watir : Ruby를 사용하는 애플리케이션 테스트 프레임워크
    
    Ruby : 인터프리터 방식의 객체지향 스크립트 언어
    

<aside>
❓ **순서가 A, B, C, D로 정해진 입력자료를 push, push, pop, push, push, pop, pop, pop 순서로 스택연산을 수행하는 경우 출력 결과는?**

</aside>

1. B D C A
2. A B C D
3. B A C D
4. A B D C

- **Answer**
    1. B D C A
    
    스택연산 : 입구 및 출구가 하나 A B C D 순으로 입력되었을때 출력순서는 D C B A 순
    
    push 입력 pop 출력
    
    push A
    
    push A B
    
    pop_ A / B
    
    push A C / B
    
    push A C D / B
    
    pop_ A C / B D
    
    pop_ A / B D C
    
    pop_ / B D C A
    

<aside>
❓ **소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?**

</aside>

1. Protability
2. Efficiency
3. Usability
4. Correctness

- **Answer**
    1. Protability
    
    이식성(Portability): 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 능력
    
    2. 효율성(Efficiency): 최소의 작업으로 요구되는 기능을 수행하는 정도
    
    3. 사용 용이성(Usability): 소프트웨어를 쉽게 사용할 수 있는 정도
    
    4. 정확성(Correctness): 사용자의 요구사항을 충족시키는 정도
    
    품질 목표 항목
    
    : 정확성, 신뢰성, 효율성, 무결성, 유지보수 용이성, 사용 용이성, 검사 용이성, 이식성, 상호 운용성, 유연성, 재사용성
    

<aside>
❓ **병렬 데이터베이스 환경 중 수평 분할에서 활용되는 분할 기법이 아닌 것은?**

</aside>

1. 라운드-로빈
2. 범위 분할
3. 예측 분할
4. 해시 분할

- **Answer**
    1. 예측 분할
    
    수평분할
    
    - 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것
    
    라운드로빈 분할
    
    - 라운드로빈 분할은 파티션에 행의 고른 분포를 원할 때 사용한다. 그러나, 해시분할과 달리 분할 칼럼을 명시할 필요가 없다. 라운드 로빈 분할로 회전하면서 새로운 행이 파티션에 할당된다. 테이블은 기본키가 반드시 필요하진 않다.
    
    파티셔닝은 병렬 데이터베이스 환경 중 수평분할에서 활용되는 분할 기법이다. 파티셔닝의 유형에는 range, hash, list, composite, round robin이 있다. 고로 답은 3번 확정!
    

<aside>
❓ **정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법은?**

</aside>

1. 인덱스 정규화
2. 반정규화
3. 집단화
4. 머징

- **Answer**
    1. 반정규화
    
    1. 인덱스 정규화 : 인덱스는 키 값으로 행 데이터의 위치를 식별하는데 사용하는 기능(인덱스 정규화는 인덱스를 효과적으로 사용하려면 정규화가 되어 있어야 하는 것을 말하는 듯)
    
    2. 반정규화 : 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
    
    3. 집단화 : 속성(유형, Type)들의 세트로 구성되는 새로운 속성(유형, Type)을 정의하는데 사용되는 개념
    
    4. 머징 : 둘 이상의 데이터 세트를 단일 데이터 세트로 결합 또는 공통된 컬럼명 또는 행 이름에 따라 데이터 프레임을 병합
    

<aside>
❓ **개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은?**

</aside>

1. 사각형 - 개체 타입
2. 삼각형 - 속성
3. 선- 개체타입과 속성을 연결
4. 마름모 - 관계 타입

- **Answer**
    1. 삼각형 - 속성
    
    - 역삼각형으로 주로 사용되며 ISA 관계(상하 관계를 가지는 관계)를 표현한다.
    - 관계 실선으로 연결하여 표현한다.
    - 상위 개체 타입: 슈퍼 클래스, 역삼각형의 위에 위치
    - 하위 개체 타입: 서브 클래스, 역삼각형의 아래에 위치

<aside>
❓ **관계형 데이터베이스에서 다음 설명에 해당하는 키(Key)는?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled%202.png)

1. 후보키
2. 대체키
3. 슈퍼키
4. 외래키

- **Answer**
    1. 슈퍼키
    
    슈퍼키 : 유일성을 만족하는 속성 또는 속성들의 집합
    
    후보키 : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합
    
    대체키 : 기본키로 선택되지 못한 후보키
    
    외래키 : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
    

<aside>
❓ **트랜잭션의 특성 중 다음 설명에 해당하는 것은?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled%203.png)

1. Durability
2. Share
3. Consistency
4. Atomicity

- **Answer**
    1. Atomicity
    
    Durability 영속성 : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
    
    Consistency 일관성 : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
    
    Atomicity 원자성 : 트랜잭션 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
    
    Isolation 격리성 : 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가하다
    

<aside>
❓ **릴레이션 R의 차수가 4이고 카디널리티가 5이며, 릴레이션 S의 차수가 6이고 카디널리티가 7일 때, 두 개의 릴레이션을 카티션 프로덕트한 결과의 새로운 릴레이 션의 차수와 카디널리티는 얼마인가?**

</aside>

1. 24, 35
2. 24, 12
3. 10, 35
4. 10, 12

- **Answer**
    1. 10, 35
    
    차수는 +를 해주고 카디널리티는 *를 해주면 해당 결과가 나옵니다.
    
    차수 = 4+6=10
    
    카디널리티 = 5*7=35
    

<aside>
❓ **3NF에서 BCNF가 되기 위한 조건은?**

</aside>

1. 이행적 함수 종속 제거
2. 부분적 함수 종속 제거
3. 다치 종속 제거
4. 결정자이면서 후보 키가 아닌 것 제거

- **Answer**
    1. 결정자이면서 후보 키가 아닌 것 제거
    
    1NF(도)-2NF(부)-3NF(이)-BCNF(결)-4NF(다)-5NF(조)
    
    도부이결다줘 = 두부이걸다줘?
    
    앞글자만 따서 순서외우면 편함
    

<aside>
❓ **운영체제에서 커널의 기능이 아닌 것은?**

</aside>

1. 프로세스 생성, 종료
2. 사용자 인터페이스
3. 기억 장치 할당, 회수
4. 파일 시스템 관리

- **Answer**
    1. 사용자 인터페이스
    
    커널(kernel) : 프로세스(CPU스케줄링)관리, 기억장치 관리, 파일관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러가지 가능 수행
    
    쉘(shell) : 시스템과 사용자간의 인터페이스 담당, 명령어 해석기
    

<aside>
❓ **다음 쉘 스크립트의 의미로 옳은 것은?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled%204.png)

1. wow 사용자가 로그인한 경우에만 반복문을 수행한다.
2. wow 사용자가 로그인할 때까지 반복문을 수행한다.
3. wow 문자열을 복사한다.
4. wow 사용자에 대한 정보를 무한 반복하여 출력한다.

- **Answer**
    1. wow 사용자가 로그인할 때까지 반복문을 수행한다.
    
    who 명령어는 현재 시스템에 로그인한 유저의 목록을 보여 준다.
    
    |(파이프)는 앞의 who 명령어의 출력 결과를 뒤의 grep 명령어로 전달한다.
    
    grep 명령어는 who 명령문의 결과 중 wow 유저가 로그인하면 그 결과를 필터링하여 출력한다.
    
    sleep 명렁문 뒤의 숫자(초)만큼 잠시 수행을 대기한다.
    

<aside>
❓ **192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?**

</aside>

1. 192.168.1.192
2. 192.168.1.195
3. 192.168.1.196
4. 192.168.1.198

- **Answer**
    1. 192.168.1.196
    
    CIDR 표기법으로 ipv4 32비트중 앞 24비트가 네트워크ip, 뒤 8비트가 호스트ip가 됩니다.
    
    여기서 4개의 서브넷으로 나누려면 호스트ip의 앞쪽 비트를 가능한 적게 4개까지 나누어줘야 하는데요
    
    2진수에서 4개로 나누려면 2비트를 사용해야 하므로
    
    192.168.1.(00)000000 (0)
    
    192.168.1.(01)000000 (64)
    
    192.168.1.(10)000000 (128)
    
    192.168.1.(11)000000 (192)
    
    로 나눌 수 있습니다.
    
    여기서 IP subnet-zero를 적용했다는것은
    
    호스트ip가 전부 0인 192.168.1.0 도 사용하겠단것을 의미 합니다.
    
    즉 4번째 네트워크는 192.168.1.192가 되겠죠?
    
    단 각 서브넷에서 호스트ip가 전부 0인 주소와 전부 1인 주소는 다른 용도로 이미 예약이 되어있습니다.(0은 네트워크 자체의 주소, 1은 브로드캐스팅 주소)
    
    즉 여기서 4번째 사용가능한 ip는
    
    193,194,195,196←이게 되는거죠
    

<aside>
❓ **CBD(Component Based Development) SW개발 표준 산출물 중 분석 단계에 해당하는 것은?**

</aside>

1. 클래스 설계서
2. 통합시험 결과서
3. 프로그램 코드
4. 사용자 요구사항 정의서

- **Answer**
    1. 사용자 요구사항 정의서
    
    CBD Component-Based Development의 약자, 컴포넌트 기반 방법론
    
    - 기존의 시스템이나 소프트웨어를 구성하는 "컴포넌트를 조합"하여 하나의 새로운 어플리케이션을 만드는 방법론
    
    CBD 방법론의 개발 공정
    
    1. 요구파악 단계 → 요구사항 기술서, 용어 사전, 개념 모델, 유즈케이스 모델
    
    2. 분석 및 설계 → 객체 모델, UI 설계서, 아키텍처 기술서, 인터페이스 명세서, 컴포넌트 명세서, 컴포넌트 설계서, 데이터베이스 설계서
    
    3. 구현 → 개발 표준 정의서, 플랫폼 종속적 코드
    
    4. 테스트 → 테스트 계획서, 컴포넌트 테스트 보고서, 통합 테스트 보고서, 인수테스트 보고서
    

<aside>
❓ **코드의 기입 과정에서 원래 '12536‘으로 기입되어야 하는데 ’12936‘으로 표기되었을 경우, 어떤 코드 오류에 해당하는가?**

</aside>

1. Addition Error
2. Omission Error
3. Sequence Error
4. Transcription Error

- **Answer**
    1. Transcription Error
    
    - 생략 오류(omission error)
    
    입력 시 한 자리를 빼놓고 기록한 경우
    
    (1234 → 123)
    
    - 필사 오류(Transcription error)
    
    입력 시 임의의 한 자리를 잘못 기록한 경우
    
    (1234 → 1235)
    
    - 전위 오류(Transposition error)
    
    입력 시 좌우 자리를 바꾸어 기록한 경우
    
    (1234 → 1243)
    
    - 이중 오류(Double Transposition error)
    
    전위 오류가 두 가지 이상 발생한 경우
    
    (1234 → 2143)
    
    - 추가 오류(Addition error)
    
    입력 시 한 자리 추가로 기록한 경우
    
    (1234 → 12345)
    
    - 임의 오류(Random error)
    
    위의 오류가 두 가지 이상 결합하여 발생한 경우
    
    (1234 → 12367)
    

<aside>
❓ **프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은?**

</aside>

1. 나선형 모형
2. 델파이 모형
3. 폭포수 모형
4. 기능점수 모형

- **Answer**
    1. 나선형 모형
    
    소프트웨어 생명 주기 모형
    
    폭포수 : 선형 순차적 / 메뉴얼 작성 / 각 단계가 끝난 뒤 다음 단계로 넘어감
    
    타당성 검토 - 계획 - 요구분석 - 설계 - 구현 - 시험 - 유지보수
    
    프로토 : 원형 모형으로 실제 개발될 제품의 견본을 만들어 결과물을 예측하는 모형
    
    개발이 완료된 시점에서 오류가 발견되는 폭포수 모형 보완
    
    요구수집 - 설계 - 구축 - 고객평가 - 조정 - 구현
    
    나선형 : 점진적 모형 / 위험을 관리 및 최소화하는 것이 목적 / 유지보수가 필요 없다
    
    애자일 : 고객 중심적 모형 / 일정 주기를 반복하면서 개발과정 진행
    

<aside>
❓ **웹페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보유출 등의 공격을 유발할 수 있는 취약점은?**

</aside>

1. Ransomware
2. Pharming
3. Phishing
4. XSS

- **Answer**
    1. XSS
    
    랜섬웨어 : 임의로 시스템을 잠그거나 혹은 데이터를 암호화하여 사용할 수 없게 한 다음 이를 빌미로 돈을 요구하는 기법.
    
    파밍 : 홈페이지 주소를 바꿔 사용자가 진짜 사이트로 오인하게 하여 접속하게 한 다음 개인정보를 탈취하는 기법.
    
    피싱 : 메일 등으로 공공기관이나 금융기관에서 보낸 것처럼 위장하여 사용자에게 계좌번호, 카드번호의 비밀번호를 빼내는 기법. 대표적으로 스미싱이 있습니다.
    

<aside>
❓ **DES는 몇 비트의 암호화 알고리즘인가?**

</aside>

1. 8
2. 24
3. 64
4. 132

- **Answer**
    1. 64
    
    DES의 키는 7비트마다 오류 검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트이다.
    
    추가적으로 AES는 암호화 알고리즘은 AES-128, AES-192, AES-256로 나뉘어지며 숫자는 비트수 이다.
    

<aside>
❓ **다음 내용이 설명하는 로그 파일은?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled%205.png)

1. tapping
2. xtslog
3. linuxer
4. wtmp

- **Answer**
    1. xtmp
    
    wtmp
    
    - 성공한 로그인/로그아웃 정보를 담고 있는 로그파일
    - var/log/wtmp에 위치
    - last 명령어 사용
    
    1,2,3 전부 없는 명령어이다.
    
    이밖에 참고로
    
    utmp
    
    - 현재 로그인 사용자 상태 정보를 담고 있는 로그파일
    
    btmp
    
    - 실패한 로그인 정보를 담고 있는 로그파일
    
    last log
    
    - 마지막으로 성공한 로그인 정보를 담고있는 로그파일

<aside>
❓ **암호화 키와 복호화 키가 동일한 암호화 알고리즘은?**

</aside>

1. RSA
2. AES
3. DSA
4. ECC

- **Answer**
    1. AES
    
    암호화 기법은 단방향인 HASH기법과 양뱡향인 공개키 기법과 개인키 기법이 있다.
    
    1. RSA는 공개키 암호화 기법으로 암호화 키는 공개키를 복호화 키는 비밀키를 사용한다.
    
    2. AES는 개인키 암호화 기법으로 암호화 키와 복호화 키가 동일하다.
    
    3. DSA는 미국의 전자서명 표준이다.
    
    4. ECC는 공개키 암호화 기법이다.
    

<aside>
❓ **UML 모델에서 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계로 옳은 것은?**

</aside>

1. Dependency
2. Realization
3. Generalization
4. Association

- **Answer**
    1. Realization
    
    Dependency(의존) : 한 사물의 명세서가 바뀌면 그것을 사용하는 다른 사물에게 영향을 끼치는 것을 말합니다 (Cascade 생각하셈)
    
    Realization(실체화) : 한 객체가 다른 객체에 의해 오퍼레이션을 수행하도록 지정
    
    Generalization(일반화) : 일반화된 사물과 좀 더 특수화된 사물 사이의 관계를 말합니다.('is-a')관계
    
    Association(연관) : 두 사물간의 구조적 관계로, 어느 한 사물 객체가 다른 사물 객체와 연결되어 있음을 말함 ('has-a')관계라고도 합니다
    

<aside>
❓ **참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?**

</aside>

1. CLUSTER
2. CASCADE
3. SET-NULL
4. RESTRICTED

- **Answer**
    1. CASECADE
    
    DDL :
    
    PRIMARY KEY : 기본키 정의 / FOREIGN KEY : 외래키 정의
    
    UNIQUE : 지정 속성은 중복값 가질 수 없음 / NO ACTION : 변화가 있어도 조취를 취하지 않음
    
    CASCADE : 참조 테이블 튜플 삭제 시 관련 튜플 모두 삭제 및 속성 변경 시 속성값 모두 변경
    
    RESTRICTED : 타 개체가 제거할 요소를 참조중이면 제거를 취소
    
    SET NULL : 참조 테이블 변화 시 기본 테이블 관련 속성값 Null로 변경
    
    SET DEFAULT : 참조 테이블 변화 시 기본테이블의 관련 튜플 속성값을 기본값으로 변경
    
    CONSTRAINT : 제약 조건 이름 지정 / CHECK 속성값에 대한 제약 조건 정의
    
    DML :
    
    INSERT INTO ~ VALUES : 튜플 삽입 / DELETE FROM~ WHERE : 튜플 삭제
    
    UPDATE ~ SET ~ WHERE : 튜플 내용 변경 / SELECT~FROM~WHERE : 튜플 검색
    
    DISTINCT : 중복 튜플 발견 시 그 중 첫번째 하나만 검색 / DISTINCTROW : 중복 튜플 제거 및 하나만 검색 (튜플 전체를 대상으로 검색)
    
    PREDICATE : 검색할 튜플 수 제한 / AS 속성명 정의
    
    ORDER BY : 특정 속성 기준으로 정렬 후 검색할 때
    
    ASC : 오름차순 / DESC : 내림차순 / 생략 시 오름차순
    
    GROUP BY : 특정 속성 기준 그룹화하여 검색할 때 사용 having절과 같이 사용되어야함
    

<aside>
❓ **리눅스 Bash 쉘(Shell)에서 export와 관련한 설명으로 틀린 것은?**

</aside>

1. 변수를 출력하고자 할 때는 export를 사용해야 한다.
2. export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력된다.
3. 사용자가 생성하는 변수는 export 명령어 표시하지 않는 한 현재 쉘에 국한된다.
4. 변수를 export 시키면 전역(Global)변수처럼 되어 끝까지 기억된다.

- **Answer**
    1. 변수를 출력하고자 할 때는 export를 사용해야 한다.
    
    리눅스에서 변수 출력은
    
    echo $변수명이다.
    

<aside>
❓ **메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?**

</aside>

1. 모드체크
2. 리커버리 통제
3. 시스로그
4. 스택가드

- **Answer**
    1. 스택가드
    
    Stack Protection : Stack Overflow를 탐지하고 보안을 강화시키는 기법
    
    Stack Guard : Stack 상에 일정한 주소번지에 프로그램이 선언한 canary를 심어 두어, 스택의 변조 된 경우에, canary를 체크하여 프로그램이 비정상적으로 종료 시키는 기법
    
    Stack Shield : 함수의 리턴주소를 복사하여 실제 리턴주소를 참조하지 않고 함수를 리턴해주는 기법
    
    Syslog : 시스템에서 로그메시지를 처리하기 위해서 제공
    
    Recovery Control : 부적절한 사건/상황으로 인해 발생한 피해를 극복, 장애/혼란을 정돈하고 정상상태로 회복
    
    + 카나리(Canary 또는 Canaries) : buffer와 SFP 사이에 buffer overflow를 탐지하기 위한 특정 값(canary value)를 삽입하는 기법
    
    + Canary  종류 : terminator, random, random XOR (스택가드는 canary 세 가지 모두를 지원)
    
    + ProPolice 종류 : terminator와 random
    
    + StackGuard와 ProPolice는 (함수 포인터들을 오버플로우하는) 자동으로 할당된 구조체들에서 오버플로우를 방어하지 못한다.
    

<aside>
❓ **다음이 설명하는 다중화 기술은?**

</aside>

![Untitled](2020~2022%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%80%E1%85%A9%E1%84%89%E1%85%A1%202%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%20a87daf516d8347cd82f2cfd4868973be/Untitled%206.png)

1. Wavelength Division Multiplexing
2. Frequency Division Multiplexing
3. Code Division Multiplexing
4. Time Division Multiplexing

- **Answer**
    1. Wavelength Division Multiplexing
    
    [다중화]
    
    : 하나의 통신 회선을 다수의 단말기가 공유할 수 있도록 하는 것, 자둥화를 위한 장치에는 다중화기, 집중화기, 공동 이용기
    
    [다중화기 종류]
    
    〮 TDM(Time Division Multiplexing)
    
    - 시분할(시간) 다중화기
    - 통신 회선의 대역폭을 일정한 시간 폭(Time slot)으로 나누어 여러 대의단말 장치가 동시에 사용할 수 있도록 한 것
    - 디지털 회선 주로 이용
    - STDM, ADTM
    
    〮 FDM(Frequency Division Multiplexing)
    
    - 주파수 분할 다중화기
    - 통신 회선의 주파수를 여러 개로 분할하여 여러 대의 단말장치가 동시에 사용할 수 있도록 한 것
    - 다중화기 중 주파수 대역폭을 다수의 작은 대역폭으로 분할 전송하는 방식
    - 간섭 방지 위한 보호 대역(Gurad Band)필요 -> 대역폭의 나비 초래
    - 저속의 비동기식전송, 멀티 포인트 방식, 아날로그 신호 전송 적합
    
    〮 CDM(Code Division Multiplexing)
    
    - 코드 분할 다중화 방식
    - 무선 통신에서 가장 널리 사용, 도청과 간섭 방지가 가능하지만 잡음을 분리해야하는 오버헤드 발생
    
    〮 WDM
    
    - 파장 분할 다중화 방식
    - 빛의 파장을 제외하고 FDM방식과 동일
    - 초고속 대용량 전송 가능
    - 시스템 확장성, 유연성 우수

<aside>
❓ **소프트웨어 정의 데이터센터(SDDC : Software Defined Data Center)에 대한 설명으로 틀린 것은?**

</aside>

1. 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의한다.
2. 인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다.
3. 데이터센터 내 모든 자원을 가상화하여 서비스한다.
4. 특정 하드웨어 에 종속되어 특화된 업무를 서비스하기에 적합하다.

- **Answer**
    1. 특정 하드웨어 에 종속되어 특화된 업무를 서비스하기에 적합하다.
    
    네트워크 관련 신기술
    
    소프트웨어 정의 데이터 센터
    
    - 데이터 센터의 모든 자원을 가상화
    - 다양한 소프트웨어 정의 기술이 사용된다.
    - 유연한 제어가능/ 비용절감가능/ 운영이 편리하다.
    - 하드웨어와 독립적이다